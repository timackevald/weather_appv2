/**
 * Le Main, monsieur! 
 **/
 
#include "include/app/weather_app.h"
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    wa_t app;

    if (app_init(&app) != 0)
    {
        printf("Application failed to start.\n");
        return 1;
    }

    printf("Weather App Started. Listening on port 8080...\n");

    while (1)
    {
        app_work(&app);
        usleep(10000);
    }

    return 0;
}
/**
 * Header file: weather_app.h
 **/

#ifndef __weather_app_h__
#define __weather_app_h__

#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/tcp/tcp_server.h"
#include "../../include/http/http_server.h"
#include "../../include/weather/weather_server.h"

typedef struct wa
{
    tcp_server_t   tcp_layer;
    http_server_t  http_layer;
    weather_server_t weather_layer;
} wa_t;

int8_t app_init(wa_t *self);
int8_t app_work(wa_t *self);

#endif /* __weather_app_h__ */
/**
 * Header-file: http_server.h
 **/
 
#ifndef __http_server_h__
#define __http_server_h__

#include <stdint.h>
#include <sys/types.h>
#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/weather/weather_server.h"
#include "../../include/tcp/tcp_connection.h"
#include "../../include/http/http_connection.h"

#define POOL_SIZE 32

typedef struct http_connection http_connection_t;
typedef struct http_server http_server_t;
typedef struct http_server_cb
{
    void (*tcp_on_newly_accepted_client)(struct http_server *self, int fd);
} http_server_cb_t;

struct http_server
{   
    uint8_t pool_size;
    uint8_t active_count;

    http_connection_t child_http_connection[POOL_SIZE];
    struct weather_server *upper_weather_server_layer;

    http_server_cb_t cb_from_tcp_layer;
    task_node_t node;
};

// int8_t http_server_work(task_node_t *node); NO NEED TO WORK RIGHT NOW!
int8_t http_server_init(http_server_t *self, struct weather_server *upper_weather_server_layer);
http_connection_t *http_server_allocate_pool_slot(http_server_t *self);
void http_server_on_new_client_cb(struct http_server *self, int fd); // Callback



#endif /* __http_server_h__ *//**
 * Header-file: http_connection.h
 **/

#ifndef __http_connection_h__
#define __http_connection_h__

#include <stdint.h>
#include "../../include/task_scheduler/task_scheduler.h"

typedef enum
{
    HTTP_CONNECTION_IDLE       = 0,
    HTTP_CONNECTION_READING    = 1,
    HTTP_CONNECTION_PROCESSING = 2,
    HTTP_CONNECTION_SENDING    = 3,
    HTTP_CONNECTION_DONE       = 4
} http_connection_state_t;

typedef struct http_connection
{
    int fd;
    http_connection_state_t state;
    struct weather_server *upper_weather_server_layer;
    struct http_server *parent; // Mama server
    task_node_t node;
} http_connection_t;

int8_t http_connection_work(task_node_t *node);

#endif /* __http_connection_h__ *//**
 * Header file: task_scheduler.h
 **/

#ifndef __task_scheduler_h__
#define __task_scheduler_h__

#include <string.h>
#include <stddef.h>
#include <stdint.h>

/**
 * container_of macro - gets parent struct from member pointer
 */
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))

typedef struct task_node task_node_t;

/**
 * Callback function that all modules will use to
 * call back to the scheduler
 **/
typedef int8_t (*task_scheduler_work_fn)(task_node_t *node);

struct task_node
{
	task_scheduler_work_fn work;
	task_node_t *next;
	uint8_t active;
	
};

typedef struct task_scheduler
{
	task_node_t *head;
	uint8_t count;
   
} task_scheduler_t;

int8_t task_scheduler_init();
int8_t task_scheduler_deinit();
int8_t task_scheduler_add(task_node_t *node);
int8_t task_scheduler_remove(task_node_t *node);
int8_t task_scheduler_work();
	
#endif /* __task_scheduler_h__ */
/**
 * Header-file. tcp_server.h
 * 
 * This module implements a non-blocking TCP server that accepts
 * incoming connections and forwards each accepted socket to
 * the upper HTTP layer through a callback.
 *
 * It does NOT store or track active connections — it just listens,
 * accepts, and passes the new file descriptor upward.
 */

#ifndef __tcp_server_h__
#define __tcp_server_h__


#include "../../include/task_scheduler/task_scheduler.h"

#define LISTEN_BKLOG 32

/* Forward declaration so we can reference http_server_t in callbacks
   without including http_server.h directly (avoids circular include). */
struct http_server;

typedef enum
{
    TCP_SERVER_INIT      = 0,
    TCP_SERVER_RESOLVING = 1,
    TCP_SERVER_LISTENING = 2,
    TCP_SERVER_ERROR     = 3,
    TCP_SERVER_DONE      = 4,
} tcp_server_state_t;

typedef struct tcp_server_cb
{
    void (*tcp_on_newly_accepted_client)(struct http_server *upper, int fd);
} tcp_server_cb_t;

/**
 * - Holds a single listening socket.
 * - Calls into upper layer (HTTP server) on accept().
 * - Integrated into the scheduler via task_node_t.
 **/
typedef struct tcp_server
{
    int listen_fd;                       
    const char *port;                    
    tcp_server_state_t state;            
    struct http_server *upper_http_layer;
    tcp_server_cb_t cb_to_http_layer;
    task_node_t node;                    
} tcp_server_t;

int8_t tcp_server_init(tcp_server_t *self, const char *port);
int8_t tcp_server_work(task_node_t *node);           
void   tcp_server_close(tcp_server_t *self);

#endif /* __tcp_server_h__ */
/**
 * Header-file: tcp_connection.h
 **/

#ifndef __tcp_connection_h__
#define __tcp_connection_h__

#include <stdint.h>
#include <unistd.h>
#include "../../include/task_scheduler/task_scheduler.h"

typedef struct tcp_connection
{
    int fd;         
} tcp_connection_t;

tcp_connection_t *tcp_connection_create(int fd);

void tcp_connection_destroy(tcp_connection_t *c);

int tcp_connection_set_nonblocking(tcp_connection_t *c);

/* Write helper (simple wrapper around write); returns number of bytes written or -1 */
ssize_t tcp_connection_write(tcp_connection_t *c, const void *buf, size_t len);

#endif /* __tcp_connection_h__ */
/**
 * Header-file: weather_server.h
 **/

#ifndef __weather_server_h__
#define __weather_server_h__

#include <stdint.h>

typedef struct weather_server
{
    int dummy;
} weather_server_t;

int8_t weather_server_init(weather_server_t *self);

#endif
/**
 * Header-file: weather_connection.h
 **//**
 * Implementation file: weather_app.c
 **/
 
 #include "../../include/app/weather_app.h"
 #include <stdio.h>
 #include <string.h>
 #include <stdint.h>
 
 int8_t app_init(wa_t *self)
 {
     if (!self) return -1;
 
     memset(self, 0, sizeof(*self));
 
     // 1. INIT scheduler
     if (task_scheduler_init() != 0)
     {
         printf("[APP] >> Failed to init scheduler.\n");
         return -1;
     }
 
     // 2. INIT weather server (upper layer)
     if (weather_server_init(&self->weather_layer) != 0)
     {
         printf("[APP] >> Failed to init weather server.\n");
         return -1;
     }
 
     // 3. INIT http server (middle layer)
     if (http_server_init(&self->http_layer, &self->weather_layer) != 0)
     {
         printf("[APP] >> Failed to init http server.\n");
         return -1;
     }
 
     // 4. Make TCP → HTTP connection
     self->tcp_layer.upper_http_layer = &self->http_layer;
     self->tcp_layer.cb_to_http_layer.tcp_on_newly_accepted_client =
         self->http_layer.cb_from_tcp_layer.tcp_on_newly_accepted_client;
 
     // 5. INIT tcp server
     if (tcp_server_init(&self->tcp_layer, "8080") != 0)
     {
         printf("[APP] >> Failed to init tcp server.\n");
         return -1;
     }
 
     printf("[APP] >> Initialization done. System ready.\n");
     return 0;
 }
 
 int8_t app_work(wa_t *self)
 {
     (void)self;
     return task_scheduler_work();
 }
 /**
 * Implementation-file: http_server.c
 **/
 
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "../../include/http/http_server.h"
#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/tcp/tcp_connection.h"

int8_t http_server_init(http_server_t *self, struct weather_server *upper_weather_server_layer)
{
    if (!self) return -1;

    memset(self, 0, sizeof(*self));
    self->pool_size = POOL_SIZE;
    self->active_count = 0;
    self->upper_weather_server_layer = upper_weather_server_layer;

    /**
     * Init pool and mark spots as free, come swim!
     **/
    for (int i = 0; i < POOL_SIZE; i++)
    {
        self->child_http_connection[i].state       = HTTP_CONNECTION_IDLE;
        self->child_http_connection[i].parent      = self;
        self->child_http_connection[i].node.work   = http_connection_work;
        self->child_http_connection[i].node.active = 0;

    }

    /* Assign callback för TCP -> HTTP hand-off */
    self->cb_from_tcp_layer.tcp_on_newly_accepted_client = http_server_on_new_client_cb;
    return 0;
}

http_connection_t *http_server_allocate_pool_slot(http_server_t *self)
{
    if (!self) return NULL;

    for (int i = 0; i < POOL_SIZE; i++)
    {
        if (self->child_http_connection[i].state == HTTP_CONNECTION_IDLE)
        {
            printf("Found a spot (location [%d]) in the pool for child process...\n", i);
            return &self->child_http_connection[i];
        }
    }
    printf("[HTTP SERVER] >> Rejecting client, pool full!\n");
    return NULL;
}

/**
 * THIS IS A CALL BACK FUNCTION, THIS IS WHERE TCP HANDS OVER CONTROL TO HTTP
 **/
void http_server_on_new_client_cb(struct http_server *self, int fd)
{
    if (!self || fd < 0) return;

    http_connection_t *connection = http_server_allocate_pool_slot(self);
    if (!connection || self->active_count >= POOL_SIZE)
    {
        printf("[HTTP SERVER] >> Rejecting client, pool full!\n");
        close(fd);
    }

    connection->fd    = fd;
    connection->state = HTTP_CONNECTION_READING;
    connection->upper_weather_server_layer = self->upper_weather_server_layer;
    /**
     * All engines start, connection is active and registered with the scheduler,
     * it will now be called upon to do some work from time to time... 
     **/
    connection->node.active = 1;
    task_scheduler_add(&connection->node);
    self->active_count++; // One more kid in the pool...
    printf("[HTTP SERVER] >> Client connection fd=%d is active and working\n", fd);
}
/**
 * Implementation-file: http_connection.c
 **/

 #include <unistd.h>
 #include <stdio.h>
 #include <string.h>
 #include "../../include/http/http_connection.h"
 #include "../../include/task_scheduler/task_scheduler.h"
 
 int8_t http_connection_work(task_node_t *node)
 {
     http_connection_t *self = container_of(node, http_connection_t, node);
 
     if (!self || self->fd < 0) return -1;
 
     switch (self->state)
     {
         case HTTP_CONNECTION_READING:
         {
             char buf[256];
             ssize_t r = read(self->fd, buf, sizeof(buf));
 
             if (r == 0)
             {
                 printf("[HTTP_CONN] >> Client closed fd=%d\n", self->fd);
                 close(self->fd);
                 self->fd = -1;
                 self->state = HTTP_CONNECTION_IDLE;
                 task_scheduler_remove(&self->node);
                 return 0;
             }
 
             if (r < 0)
             {
                 /* Non-blocking wait */
                 return 0;
             }
 
             printf("[HTTP_CONN] >> Received %ld bytes on fd=%d\n", r, self->fd);
 
             /* Later you’ll parse HTTP request here */
             self->state = HTTP_CONNECTION_SENDING;
             return 0;
         }
 
         case HTTP_CONNECTION_SENDING:
         {
             const char *resp =
                 "HTTP/1.1 200 OK\r\n"
                 "Content-Type: text/plain\r\n"
                 "Content-Length: 12\r\n"
                 "\r\n"
                 "Hello World\n";
 
             write(self->fd, resp, strlen(resp));
             close(self->fd);
             self->fd = -1;
 
             printf("[HTTP_CONN] >> Response sent, closing fd.\n");
 
             self->state = HTTP_CONNECTION_IDLE;
             task_scheduler_remove(&self->node);
 
             return 0;
         }
 
         default:
         {
            return 0;
         }
     }
 
     return 0;
 }
 

/**
 * Implementation file: task_scheduler.c
 **/

#include "../../include/task_scheduler/task_scheduler.h"
#include <stdint.h>
#include <string.h>
#include <stdio.h>

/**
 * Singelton object: 
 **/
static task_scheduler_t g_task_scheduler;

int8_t task_scheduler_init()
{
	memset(&g_task_scheduler, 0, sizeof(g_task_scheduler));
	
	return 0;
}

int8_t task_scheduler_deinit()
{
	/**
	 * Nodes are embedded in module struct
	 * can't call free on them
	 **/
	g_task_scheduler.head = NULL;
	g_task_scheduler.count = 0;
	
	return 0;
}

int8_t task_scheduler_add(task_node_t *node)
{
	if (!node || !node->work) return -1;
	if (node->active) return -1;

	node->next = g_task_scheduler.head;
	g_task_scheduler.head = node;
	node->active = 1;
	g_task_scheduler.count++;

	return 0;	
}

int8_t task_scheduler_remove(task_node_t *node)
{
	if (!node) return -1;

	task_node_t *curr = g_task_scheduler.head;
	task_node_t *prev = NULL;
	while (curr)
	{
		if (curr == node) // Found node
		{
			if (prev) // Decouple node
			{
				prev->next = curr->next;
			}
			else
			{
				g_task_scheduler.head = curr->next;
			}
			node->next   = NULL;
			node->active = 0;
			g_task_scheduler.count--;

			return 0;
		}
		prev = curr;
		curr = curr->next;
	}

	return -1;
}

int8_t task_scheduler_work()
{
    //printf("[SCHEDULER] >> Running, count=%d\n", g_task_scheduler.count); // Debugg
	task_node_t *node = g_task_scheduler.head;
	while (node)
	{
		if (node->active && node->work)
		{
			int8_t work = node->work(node);
			if (work != 0)
			{
				printf("[SCHEDULER] >> Task failed, removing it from list.\n");
				task_scheduler_remove(node);
			}
		}
		node = node->next;
	}

	return 0;
}
/**
 * Implementation-file: tcp_server.c
 **/

#define _POSIX_C_SOURCE 200112L
#define _DEFAULT_SOURCE

#include <stdio.h>       
#include <stdlib.h>      
#include <string.h>      
#include <stdint.h>       
#include <errno.h>       
#include <fcntl.h>       
#include <unistd.h>       
#include <sys/types.h>   
#include <sys/socket.h>  
#include <netdb.h>       

#include "../../include/tcp/tcp_server.h"
#include "../../include/task_scheduler/task_scheduler.h"


static int set_nonblocking_fd(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1;

    return 0;
}

int8_t tcp_server_init(tcp_server_t *self, const char *port)
{
    if (!self || !port) return -1;
    memset(self, 0, sizeof(*self));
    
    self->port  = port;
    self->state = TCP_SERVER_INIT; /* Start the state-machine */
    
    struct addrinfo hints;
    struct addrinfo *res = NULL;
    
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC; /* prefer AF_INET/AF_INET6 but allow both */
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;

    int ret = getaddrinfo(NULL, port, &hints, &res);
    if (ret != 0) {
        printf("[TCP] >> getaddrinfo failed: %s\n", gai_strerror(ret));
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    int listen_fd = -1;
    struct addrinfo *rp;

    for (rp = res; rp != NULL; rp = rp->ai_next)
    {
        listen_fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (listen_fd == -1) continue;
        int opt = 1;
        setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        if (bind(listen_fd, rp->ai_addr, rp->ai_addrlen) == 0) break;
        close(listen_fd);
        listen_fd = -1;
    }
    freeaddrinfo(res);

    if (listen_fd == -1)
    {
        printf("[TCP] >> bind/listen failed on port %s\n", port);
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    if (set_nonblocking_fd(listen_fd) != 0)
    {
        perror("[TCP] >> fcntl");
        close(listen_fd);
        self->state = TCP_SERVER_ERROR;
        
        return -1;
    }

    if (listen(listen_fd, LISTEN_BKLOG) < 0)
    {
        perror("[TCP] >> listen");
        close(listen_fd);
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    self->listen_fd = listen_fd;
    self->state = TCP_SERVER_LISTENING;
    self->node.work = tcp_server_work;
    //self->node.active = 1; Le Problem
    task_scheduler_add(&self->node);
    printf("[TCP] >> Listening on port %s\n", port);

    return 0;
}

int8_t tcp_server_work(task_node_t *node)
{
    //printf("[TCP_SERVER_WORK] >> Called\n"); // Debgg
    tcp_server_t *self = container_of(node, tcp_server_t, node);
    if (!self || self->state != TCP_SERVER_LISTENING) return 0;

    struct sockaddr_storage client_addr;
    socklen_t addrlen = sizeof(client_addr);

    for (;;)
    {
        int client_fd = accept(self->listen_fd, (struct sockaddr*)&client_addr,&addrlen);
        if (client_fd < 0)
        {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                break;
            }
            perror("[TCP] >> accept");
            break;
        }

        set_nonblocking_fd(client_fd);
        printf("Accepted client connection of fd=%d\n", client_fd);
        
        /**
         * HERE IS THE CALLBACK TO THE HTTP_LAYER!
         * SEND THE NEWLY ACCEPTED CLIENT UPWARDS!
         **/
        if (self->upper_http_layer && self->cb_to_http_layer.tcp_on_newly_accepted_client)
        {
            self->cb_to_http_layer.tcp_on_newly_accepted_client(self->upper_http_layer, client_fd);
        }
    }

    return 0;
}

void tcp_server_close(tcp_server_t *self)
{
    if (!self) return;
    if (self->listen_fd >= 0) close(self->listen_fd);
    self->listen_fd = -1;
    self->state = TCP_SERVER_ERROR;
}
/**
 * Implementation-file: tcp_connection.c
 **/

#include "../../include/tcp/tcp_connection.h"
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>

tcp_connection_t *tcp_connection_create(int fd)
{
    if (fd < 0) return NULL;
    tcp_connection_t *connection = malloc(sizeof(*connection));
    if (!connection) return NULL;
    connection->fd = fd;
    /* caller usually sets non-blocking, but do it here for safety */
    tcp_connection_set_nonblocking(connection);
    return connection;
}

void tcp_connection_destroy(tcp_connection_t *connection)
{
    if (!connection) return;
    if (connection->fd >= 0) close(connection->fd);
    free(connection);
}

int tcp_connection_set_nonblocking(tcp_connection_t *connection)
{
    if (!connection) return -1;
    int flags = fcntl(connection->fd, F_GETFL, 0);
    if (flags == -1) return -1;
    if (fcntl(connection->fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1;
    return 0;
}

ssize_t tcp_connection_write(tcp_connection_t *connection, const void *buf, size_t len)
{
    if (!connection || connection->fd < 0) return -1;
    return write(connection->fd, buf, len);
}
/**
 * Implementation-file: weather_server.c
 **/

 #include "../../include/weather/weather_server.h"
 #include <string.h>
 
 int8_t weather_server_init(weather_server_t *self)
 {
     if (!self) return -1;
     memset(self, 0, sizeof(*self));
     return 0;
 }
 
/**
 * Implementation-file: weather_connection.h
 **/