/**
 * Le Main, monsieur! 
 **/
 
#include "include/app/weather_app.h"
#include "include/task_scheduler/task_scheduler.h"
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    wa_t app;

    if (app_init(&app) != 0)
    {
        printf("Application failed to start.\n");
        return 1;
    }

    printf("Weather App Started. Listening on port 8080...\n");

    while (1)
    {
		task_scheduler_run();
    }

    return 0;
}
/**
 * Header file: weather_app.h
 **/

#ifndef __weather_app_h__
#define __weather_app_h__

#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/tcp/tcp_server.h"
#include "../../include/http/http_server.h"
#include "../../include/weather/weather_server.h"

typedef struct wa
{
    tcp_server_t   tcp_layer;
    http_server_t  http_layer;
    weather_server_t weather_layer;
} wa_t;

int8_t app_init(wa_t *self);
int8_t app_work(wa_t *self);

#endif /* __weather_app_h__ */
/**
 * Header-file: http_server.h
 **/
 
#ifndef __http_server_h__
#define __http_server_h__

#include <stdint.h>
#include <sys/types.h>
#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/weather/weather_server.h"
#include "../../include/http/http_connection.h"

#define POOL_SIZE 32

typedef struct http_connection http_connection_t;
typedef struct http_server http_server_t;
typedef struct http_server_cb
{
    void (*tcp_on_newly_accepted_client)(struct http_server *self, int fd);
} http_server_cb_t;

struct http_server
{   
    uint8_t pool_size;
    uint8_t active_count;

    http_connection_t child_http_connection[POOL_SIZE];
    struct weather_server *upper_weather_server_layer;

    http_server_cb_t cb_from_tcp_layer;
    task_node_t node;
};

// int8_t http_server_work(task_node_t *node); NO NEED TO WORK RIGHT NOW!
int8_t http_server_init(http_server_t *self, struct weather_server *upper_weather_server_layer);
http_connection_t *http_server_allocate_pool_slot(http_server_t *self);
void http_server_on_new_client_cb(struct http_server *self, int fd); // Callback



#endif /* __http_server_h__ */
/**
 * Header-file: http_connection.h
 **/

#ifndef __http_connection_h__
#define __http_connection_h__

#include <stdint.h>
#include "../../include/task_scheduler/task_scheduler.h"

typedef enum
{
    HTTP_CONNECTION_IDLE       = 0,
    HTTP_CONNECTION_READING    = 1,
	HTTP_CONNECTION_PARSING    = 2,
    HTTP_CONNECTION_PROCESSING = 3,
	HTTP_CONNECTION_WAITING    = 4,
    HTTP_CONNECTION_SENDING    = 5,
    HTTP_CONNECTION_DONE       = 6
} http_connection_state_t;

typedef struct http_connection_request
{
	char method[16];
	char path[256];
	char query[256];
	char body[512];
} http_connection_request_t;

typedef struct http_connection_cb
{
	void (*weather_on_handled_request)(struct http_connection *self, const char *weather_data);
} http_connection_cb_t;


typedef struct http_connection
{
    int fd;
    http_connection_state_t state;
    struct http_server *parent; // Mama server
    task_node_t node;

	char raw_http_buffer[1024]; // Raw http request goes here
	http_connection_request_t parsed_request;
	char http_on_handled_request_response_buffer[2048]; // Response to client
	http_connection_cb_t cb_from_weather_layer;	// Callback from weather layer
} http_connection_t;

int8_t http_connection_work(task_node_t *node);
void http_connection_on_handled_request(struct http_connection *self, const char *weather_data);

#endif /* __http_connection_h__ */
/**
 * Header file: task_scheduler.h
 **/

#ifndef __task_scheduler_h__
#define __task_scheduler_h__

#include <string.h>
#include <stddef.h>
#include <stdint.h>

#define MAX_FD 64 //Configure me :)

/**
 * container_of macro - gets parent struct from member pointer
 */
#define container_of(ptr, type, member) \
    ((type *)((char *)(ptr) - offsetof(type, member)))

typedef struct task_node task_node_t;

/**
 * Callback function that all modules will use to
 * call back to the scheduler
 **/
typedef int8_t (*task_scheduler_work_fn)(task_node_t *node);

struct task_node
{
	task_scheduler_work_fn work;
	task_node_t *next;
	uint8_t active;
	
};

typedef struct task_scheduler
{
	task_node_t *head;
	uint8_t     count;
	int         fds[MAX_FD]; // Configure me!
	uint8_t     fd_count;
   
} task_scheduler_t;

int8_t task_scheduler_init();
int8_t task_scheduler_deinit();
int8_t task_scheduler_add(task_node_t *node);
int8_t task_scheduler_remove(task_node_t *node);
int8_t task_scheduler_work();
int8_t task_scheduler_reg_fd(int fd);
int8_t task_scheduler_dereg_fd(int fd);
int8_t task_scheduler_run();
	
#endif /* __task_scheduler_h__ */
/**
 * Header-file. tcp_server.h
 * 
 * This module implements a non-blocking TCP server that accepts
 * incoming connections and forwards each accepted socket to
 * the upper HTTP layer through a callback.
 *
 * It does NOT store or track active connections — it just listens,
 * accepts, and passes the new file descriptor upward.
 */

#ifndef __tcp_server_h__
#define __tcp_server_h__


#include "../../include/task_scheduler/task_scheduler.h"

#define LISTEN_BKLOG 32

/* Forward declaration so we can reference http_server_t in callbacks
   without including http_server.h directly (avoids circular include). */
struct http_server;

typedef enum
{
    TCP_SERVER_INIT      = 0,
    TCP_SERVER_RESOLVING = 1,
    TCP_SERVER_LISTENING = 2,
    TCP_SERVER_ERROR     = 3,
    TCP_SERVER_DONE      = 4,
} tcp_server_state_t;

typedef struct tcp_server_cb
{
    void (*tcp_on_newly_accepted_client)(struct http_server *upper, int fd);
} tcp_server_cb_t;

/**
 * - Holds a single listening socket.
 * - Calls into upper layer (HTTP server) on accept().
 * - Integrated into the scheduler via task_node_t.
 **/
typedef struct tcp_server
{
    int listen_fd;                       
    const char *port;                    
    tcp_server_state_t state;            
    struct http_server *upper_http_layer;
    tcp_server_cb_t cb_to_http_layer;
    task_node_t node;                    
} tcp_server_t;

int8_t tcp_server_init(tcp_server_t *self, const char *port);
int8_t tcp_server_work(task_node_t *node);           
void   tcp_server_close(tcp_server_t *self);

#endif /* __tcp_server_h__ */
/**
 * Header-file: weather_server.h
 **/

#ifndef __weather_server_h__
#define __weather_server_h__

#include <stdint.h>
#include "../../include/weather/weather_connection.h"

#define WEATHER_POOL_SIZE 32

typedef struct weather_server
{
    uint8_t pool_size;
    uint8_t active_count;
    
    weather_connection_t child_weather_connection[WEATHER_POOL_SIZE];
} weather_server_t;

int8_t weather_server_init(weather_server_t *self);
weather_connection_t *weather_server_allocate_pool_slot(weather_server_t *self);

#endif
/**
 * Header-file: weather_connection.h
 **/

#ifndef __weather_connection_h__
#define __weather_connection_h__

#include <stdint.h>
#include "../../include/task_scheduler/task_scheduler.h"

// Forward declare to avoid circular dependency
struct http_request;
struct http_connection;

typedef enum
{
    WEATHER_CONNECTION_IDLE       = 0,
    WEATHER_CONNECTION_PROCESSING = 1,
    WEATHER_CONNECTION_DONE       = 2
} weather_connection_state_t;

/* Callback structure for HTTP -> Weather */
typedef struct weather_connection_cb
{
    void (*http_on_new_request)(struct weather_connection *self, const struct http_request *request);
} weather_connection_cb_t;

typedef struct weather_connection
{
    weather_connection_state_t state;
    struct weather_server *parent;
    struct http_connection *lower_http_connection;  // Back reference to HTTP child
    task_node_t node;
    
    // Request info
    char request_type[32];  // "current", "forecast", etc.
    char city[64];
    
    // Response
    char response[512];
    
    // Callback FROM HTTP layer
    weather_connection_cb_t cb_from_http_layer;
} weather_connection_t;

int8_t weather_connection_work(task_node_t *node);
void weather_connection_on_request_cb(struct weather_connection *self, const struct http_request *request);

#endif
/**
 * Implementation file: weather_app.c
 **/
 
 #include "../../include/app/weather_app.h"
 #include <stdio.h>
 #include <string.h>
 #include <stdint.h>
 
int8_t app_init(wa_t *self)
{
    if (!self) return -1;

    memset(self, 0, sizeof(*self));

    // 1. INIT scheduler
    if (task_scheduler_init() != 0)
    {
        printf("[APP] >> Failed to init scheduler.\n");
        return -1;
    }

    // 2. INIT weather server (upper layer)
    if (weather_server_init(&self->weather_layer) != 0)
    {
        printf("[APP] >> Failed to init weather server.\n");
        return -1;
    }

    // 3. INIT http server (middle layer)
    if (http_server_init(&self->http_layer, &self->weather_layer) != 0)
    {
        printf("[APP] >> Failed to init http server.\n");
        return -1;
    }

    // 4. INIT tcp server
    if (tcp_server_init(&self->tcp_layer, "8080") != 0)
    {
        printf("[APP] >> Failed to init tcp server.\n");
        return -1;
    }

    // 5. Make TCP → HTTP connection
    self->tcp_layer.upper_http_layer = &self->http_layer;
    self->tcp_layer.cb_to_http_layer.tcp_on_newly_accepted_client =
        self->http_layer.cb_from_tcp_layer.tcp_on_newly_accepted_client;

    printf("[APP] >> Initialization done. System ready.\n");
    return 0;
}
 
int8_t app_work(wa_t *self)
{
    (void)self;
    return task_scheduler_work();
}
 
/**
 * Implementation-file: http_server.c
 **/
 
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include "../../include/http/http_server.h"
#include "../../include/task_scheduler/task_scheduler.h"

int8_t http_server_init(http_server_t *self, struct weather_server *upper_weather_server_layer)
{
    if (!self) return -1;

    memset(self, 0, sizeof(*self));
    self->pool_size = POOL_SIZE;
    self->active_count = 0;
    self->upper_weather_server_layer = upper_weather_server_layer;

    /**
     * Init pool and mark spots as free, come swim!
     **/
    for (int i = 0; i < POOL_SIZE; i++)
    {
        self->child_http_connection[i].state       = HTTP_CONNECTION_IDLE;
        self->child_http_connection[i].parent      = self;
        self->child_http_connection[i].node.work   = http_connection_work;
		self->child_http_connection[i].cb_from_weather_layer.weather_on_handled_request = http_connection_on_handled_request;
        self->child_http_connection[i].node.active = 0;

    }

    /* Assign callback för TCP -> HTTP hand-off */
    self->cb_from_tcp_layer.tcp_on_newly_accepted_client = http_server_on_new_client_cb;
    return 0;
}

http_connection_t *http_server_allocate_pool_slot(http_server_t *self)
{
    if (!self) return NULL;

    for (int i = 0; i < POOL_SIZE; i++)
    {
        if (self->child_http_connection[i].state == HTTP_CONNECTION_IDLE)
        {
            printf("Found a spot (location [%d]) in the pool for child process...\n", i);
            return &self->child_http_connection[i];
        }
    }
    printf("[HTTP SERVER] >> Rejecting client, pool full!\n");
    return NULL;
}

/**
 * THIS IS A CALL BACK FUNCTION, THIS IS WHERE TCP HANDS OVER CONTROL TO HTTP
 **/
void http_server_on_new_client_cb(struct http_server *self, int fd)
{
    if (!self || fd < 0) return;

    http_connection_t *connection = http_server_allocate_pool_slot(self);
    if (!connection || self->active_count >= POOL_SIZE)
    {
        printf("[HTTP SERVER] >> Rejecting client, pool full!\n");
        close(fd);
    }

    connection->fd    = fd;
    connection->state = HTTP_CONNECTION_READING;
    /**
     * All engines start, connection is active and registered with the scheduler,
     * it will now be called upon to do some work from time to time... 
     **/
    connection->node.active = 0;
    task_scheduler_add(&connection->node);
	task_scheduler_reg_fd(fd);
    self->active_count++; // One more kid in the pool...
    printf("[HTTP SERVER] >> Client connection fd=%d is active and working\n", fd);
}
/**
 * Implementation-file: http_connection.c
 **/

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "../../include/http/http_connection.h"
#include "../../include/task_scheduler/task_scheduler.h"
#include "../../include/weather/weather_server.h"
#include "../../include/weather/weather_connection.h"
#include "../../include/http/http_parser.h"


/**
 * THIS IA CALLBACK FUNCTION, WEATHER CHILD GIVES BACK RESPONSE TO HTTP CHILD
 **/
void http_connection_on_handled_request(struct http_connection *self, const char *weather_data)
{
	if (!self || !weather_data) return;
	printf("[HTTP CONNECTION] >> HTTP child now has weather childs response to client.\n");
	/**
	 * MOCK UP WITH snprintf() FOR NOW! USE http_parser-lib LATER INSTEAD!
	 **/
	snprintf(self->http_on_handled_request_response_buffer,
			 sizeof(self->http_on_handled_request_response_buffer),
		"HTTP/1.1 200 OK\r\n"
		"Content-type: text/plain\r\n"
		"Content-Length: %zu\r\n"
		"\r\n"
		"%s", strlen(weather_data), weather_data);
	self->state = HTTP_CONNECTION_SENDING;
	printf("[HTTP CONNECTION] >> HTTP child will try to send response to client...\n");
}

/**
 * THIS IS FOR TESTING, WILL BE REPLACED WITH http_parse-lib IN THE FUTURE!
 **/
static void parse_http_request(const char *raw, http_connection_request_t *req)
{
    memset(req, 0, sizeof(*req));
    
    // Parse first line: "GET /path?query HTTP/1.1"
    const char *space1 = strchr(raw, ' ');
    if (!space1) return;
    
    // Extract method
    size_t method_len = space1 - raw;
    if (method_len >= sizeof(req->method)) method_len = sizeof(req->method) - 1;
    strncpy(req->method, raw, method_len);
    
    // Find path
    const char *path_start = space1 + 1;
    const char *space2 = strchr(path_start, ' ');
    if (!space2) return;
    
    // Check for query string
    const char *query_start = strchr(path_start, '?');
    
    if (query_start && query_start < space2)
    {
        // Has query string
        size_t path_len = query_start - path_start;
        if (path_len >= sizeof(req->path)) path_len = sizeof(req->path) - 1;
        strncpy(req->path, path_start, path_len);
        
        size_t query_len = space2 - (query_start + 1);
        if (query_len >= sizeof(req->query)) query_len = sizeof(req->query) - 1;
        strncpy(req->query, query_start + 1, query_len);
    }
    else
    {
        // No query string
        size_t path_len = space2 - path_start;
        if (path_len >= sizeof(req->path)) path_len = sizeof(req->path) - 1;
        strncpy(req->path, path_start, path_len);
    }
    
    printf("[HTTP_PARSER] >> Method: %s, Path: %s, Query: %s\n", 
           req->method, req->path, req->query);
}

int8_t http_connection_work(task_node_t *node)
{
    http_connection_t *self = container_of(node, http_connection_t, node);
    
    printf("[HTTP CONNECTION WORK] >> Called, state=%d, fd=%d\n", self->state, self->fd);

    if (!self || self->fd < 0) return -1;

    switch (self->state)
    {
        case HTTP_CONNECTION_READING:
        {
            char buf[256];
            ssize_t r = read(self->fd, buf, sizeof(buf));
            
            printf("[HTTP CONNECTION] >> read() returned %ld, errno=%d\n", r, errno);

            if (r == 0)
            {
                printf("[HTTP CONNECTION] >> Client closed fd=%d\n", self->fd);
				task_scheduler_dereg_fd(self->fd);
                close(self->fd);
                self->fd = -1;
                self->state = HTTP_CONNECTION_IDLE;
                task_scheduler_remove(&self->node);
                return 0;
            }

            if (r < 0)
            {
                if (errno == EAGAIN || errno == EWOULDBLOCK)
                {
                    printf("[HTTP CONNECTION] >> No data yet (EAGAIN), will try again\n");
                    return 0;
                }
                printf("[HTTP CONNECTION] >> Read error: %d\n", errno);
                return 0;
            }

            printf("[HTTP CONNECTION] >> Received %ld bytes on fd=%d\n", r, self->fd);

			/**
			 * IF BIGGER THAN BUFFER, CHOP IT!
			 **/
			size_t copy_len = r < (ssize_t)sizeof(self->raw_http_buffer) ? (size_t)r : sizeof(self->raw_http_buffer) - 1;
			memcpy(self->raw_http_buffer, buf, copy_len);
			self->raw_http_buffer[copy_len] = '\0';
            self->state = HTTP_CONNECTION_PARSING;
			
            return 0;
        }
	    case HTTP_CONNECTION_PARSING:
		{
			printf("[HTTP CONNETION] >> HTTP child parsing request...\n");
			parse_http_request(self->raw_http_buffer, &self->parsed_request);
			self->state = HTTP_CONNECTION_PROCESSING;
			
			return 0;
		}

case HTTP_CONNECTION_PROCESSING:
		{
			// Fixed typo: CONNETION -> CONNECTION
			printf("[HTTP CONNECTION] HTTP child handing over request to weather child...\n");
			
			// IF 1: Check if the upper layer exists
			if (self->parent && self->parent->upper_weather_server_layer)
			{
				weather_connection_t *weather_connection =
					weather_server_allocate_pool_slot(self->parent->upper_weather_server_layer);

				// IF 2: Check if allocation from the pool was successful
				if (weather_connection)
				{
					weather_connection->lower_http_connection = self;
					// Fixed typo: callbacm -> callback
					printf("[HTTP CONNECTION] >> HTTP child got Weather child\n"
						   "[HTTP CONNECTION] >> Calling its callback...\n");
					weather_connection->cb_from_http_layer.http_on_new_request(
						weather_connection, &self->parsed_request);
					// Fixed typo: HTPP CONNETION -> HTTP CONNECTION
					printf("[HTTP CONNECTION] >> Returned from callback!\n");
					self->state = HTTP_CONNECTION_WAITING;
				}
				else // ELSE 2: Paired with IF 2 (Allocation failed)
                {
                    // Weather pool full, send error
                    printf("[HTTP_CONN] >> Weather pool full, sending error\n");
                    snprintf(self->http_on_handled_request_response_buffer, sizeof(self->http_on_handled_request_response_buffer),
                        "HTTP/1.1 503 Service Unavailable\r\n"
                        "Content-Type: text/plain\r\n"
                        "Content-Length: 21\r\n"
                        "\r\n"
                        "Service Unavailable\n");
                    self->state = HTTP_CONNECTION_SENDING;
                }
   				
				// This return was inside the original 'if' block,
				// so it executes after either IF 2 or ELSE 2.
				return 0;
			}
   			else // ELSE 1: Paired with IF 1 (No upper layer)
			{
				/**
				 * REMOVE THIS IN THE FUTURE, JUST FOR TESTNING
				 **/
                printf("[HTTP_CONN] >> No weather layer configured\n");
                snprintf(self->response_buffer, sizeof(self->response_buffer),
                    "HTTP/1.1 200 OK\r\n"
                    "Content-Type: text/plain\r\n"
                    "Content-Length: 12\r\n"
                    "\r\n"
                    "Hello World\n");
				
				// Fixed typo: self.state -> self->state
                self->state = HTTP_CONNECTION_SENDING;
				
				// This path has also handled the request, so it should return 0
				// to prevent falling through the switch.
				return 0;
		}

        case HTTP_CONNECTION_SENDING:
        {
            printf("[HTTP CONNECTION] >> Sending response...\n");
            
            ssize_t written = write(self->fd, self->http_on_handled_request_response_buffer,
									strlen(self->http_on_handled_request_response_buffer));
            printf("[HTTP_CONN] >> Wrote %ld bytes\n", written);
            
			task_scheduler_dereg_fd(self->fd);
            close(self->fd);
            self->fd = -1;

            printf("[HTTP_CONN] >> Response sent, closing fd.\n");

            self->state = HTTP_CONNECTION_IDLE;
            task_scheduler_remove(&self->node);

            return 0;
        }

        default:
        {
            return 0;
        }
    }

    return 0;
}
/**
 * Implementation file: task_scheduler.c
 **/

#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <sys/select.h>
#include <errno.h>

#include "../../include/task_scheduler/task_scheduler.h"

/**
 * Singelton object: 
 **/
static task_scheduler_t g_task_scheduler;

int8_t task_scheduler_init()
{
	memset(&g_task_scheduler, 0, sizeof(g_task_scheduler));

	for (int i = 0; i < MAX_FD; i++)
	{
		g_task_scheduler.fds[i] = -1; // Set to invalid state
	}
	
	return 0;
}

int8_t task_scheduler_deinit()
{
	g_task_scheduler.head = NULL;
	g_task_scheduler.count = 0;
	
	return 0;
}

int8_t task_scheduler_add(task_node_t *node)
{
	if (!node || !node->work) return -1;
	if (node->active) return -1;

	node->next = g_task_scheduler.head;
	g_task_scheduler.head = node;
	node->active = 1;
	g_task_scheduler.count++;

	return 0;	
}

int8_t task_scheduler_remove(task_node_t *node)
{
	if (!node) return -1;

	task_node_t *curr = g_task_scheduler.head;
	task_node_t *prev = NULL;
	while (curr)
	{
		if (curr == node) // Found node
		{
			if (prev) // Decouple node
			{
				prev->next = curr->next;
			}
			else
			{
				g_task_scheduler.head = curr->next;
			}
			node->next   = NULL;
			node->active = 0;
			g_task_scheduler.count--;

			return 0;
		}
		prev = curr;
		curr = curr->next;
	}

	return -1;
}

int8_t task_scheduler_work()
{
    //printf("[SCHEDULER] >> Running, count=%d\n", g_task_scheduler.count); // Debugg
	task_node_t *node = g_task_scheduler.head;
	while (node)
	{
		if (node->active && node->work)
		{
			int8_t work = node->work(node);
			if (work != 0)
			{
				printf("[SCHEDULER] >> Task failed, removing it from list.\n");
				task_scheduler_remove(node);
			}
		}
		node = node->next;
	}

	return 0;
}

int8_t task_scheduler_reg_fd(int fd)
{
	if (fd < 0) return -1;
	if (g_task_scheduler.fd_count >= 64) return -1;
	
	/* Check if already registered */
	for (int i = 0; i < g_task_scheduler.fd_count; i++)
	{
		if (g_task_scheduler.fds[i] == fd) return 0; /* Already registered */
	}
	
	g_task_scheduler.fds[g_task_scheduler.fd_count++] = fd;
	return 0;
}

int8_t task_scheduler_dereg_fd(int fd)
{
    if (fd < 0) return -1;
    
    for (int i = 0; i < g_task_scheduler.fd_count; i++)
    {
        if (g_task_scheduler.fds[i] == fd)
        {
            // Swap with last valid element
            g_task_scheduler.fds[i] = g_task_scheduler.fds[g_task_scheduler.fd_count - 1];
            g_task_scheduler.fds[g_task_scheduler.fd_count - 1] = -1;  // Mark old spot as invalid
            g_task_scheduler.fd_count--;
            return 0;
        }
    }
    
    return -1;
}

/**
 * Use select() to wait for I/O activity on registered file descriptors
 * This blocks until there's activity or timeout, then runs all tasks
 **/
int8_t task_scheduler_run()
{
	fd_set readfds;
	FD_ZERO(&readfds);
	
	int max_fd = -1;
	
	/* Add all registered file descriptors to the set */
	for (int i = 0; i < g_task_scheduler.fd_count; i++)
	{
		int fd = g_task_scheduler.fds[i];
		FD_SET(fd, &readfds);
		if (fd > max_fd) max_fd = fd;
	}
	
	/* Set timeout to 10ms so we still poll regularly */
	struct timeval timeout;
	timeout.tv_sec = 0;
	timeout.tv_usec = 10000;  /* 10ms */
	int ready = select(max_fd + 1, &readfds, NULL, NULL, &timeout);
	
	if (ready < 0)
	{
		if (errno == EINTR) return 0;  /* Interrupted, just continue */
		perror("[SCHEDULER] >> select");
		return -1;
	}
	
	/* Run all tasks (they'll check their own fds) */
	return task_scheduler_work();
}
/**
 * Implementation-file: tcp_server.c
 **/

#define _POSIX_C_SOURCE 200112L
#define _DEFAULT_SOURCE

#include <stdio.h>       
#include <stdlib.h>      
#include <string.h>      
#include <stdint.h>       
#include <errno.h>       
#include <fcntl.h>       
#include <unistd.h>       
#include <sys/types.h>   
#include <sys/socket.h>  
#include <netdb.h>       

#include "../../include/tcp/tcp_server.h"
#include "../../include/task_scheduler/task_scheduler.h"


static int set_nonblocking_fd(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) return -1;
    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return -1;

    return 0;
}

int8_t tcp_server_init(tcp_server_t *self, const char *port)
{
    if (!self || !port) return -1;
    memset(self, 0, sizeof(*self));
    
    self->port  = port;
    self->state = TCP_SERVER_INIT; /* Start the state-machine */
    
    struct addrinfo hints;
    struct addrinfo *res = NULL;
    
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC; /* prefer AF_INET/AF_INET6 but allow both */
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;

    int ret = getaddrinfo(NULL, port, &hints, &res);
    if (ret != 0) {
        printf("[TCP] >> getaddrinfo failed: %s\n", gai_strerror(ret));
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    int listen_fd = -1;
    struct addrinfo *rp;

    for (rp = res; rp != NULL; rp = rp->ai_next)
    {
        listen_fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (listen_fd == -1) continue;
        int opt = 1;
        setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        if (bind(listen_fd, rp->ai_addr, rp->ai_addrlen) == 0) break;
        close(listen_fd);
        listen_fd = -1;
    }
    freeaddrinfo(res);

    if (listen_fd == -1)
    {
        printf("[TCP] >> bind/listen failed on port %s\n", port);
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    if (set_nonblocking_fd(listen_fd) != 0)
    {
        perror("[TCP] >> fcntl");
        close(listen_fd);
        self->state = TCP_SERVER_ERROR;
        
        return -1;
    }

    if (listen(listen_fd, LISTEN_BKLOG) < 0)
    {
        perror("[TCP] >> listen");
        close(listen_fd);
        self->state = TCP_SERVER_ERROR;

        return -1;
    }

    self->listen_fd = listen_fd;
    self->state = TCP_SERVER_LISTENING;
    self->node.work = tcp_server_work;
    //self->node.active = 1; Le Problem
    task_scheduler_add(&self->node);
	task_scheduler_reg_fd(listen_fd);
	
    printf("[TCP] >> Listening on port %s\n", port);

    return 0;
}

int8_t tcp_server_work(task_node_t *node)
{
    //printf("[TCP_SERVER_WORK] >> Called\n"); // Debgg
    tcp_server_t *self = container_of(node, tcp_server_t, node);
    if (!self || self->state != TCP_SERVER_LISTENING) return 0;

    struct sockaddr_storage client_addr;
    socklen_t addrlen = sizeof(client_addr);

    for (;;)
    {
        int client_fd = accept(self->listen_fd, (struct sockaddr*)&client_addr,&addrlen);
        if (client_fd < 0)
        {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                break;
            }
            perror("[TCP] >> accept");
            break;
        }

        set_nonblocking_fd(client_fd);
        printf("Accepted client connection of fd=%d\n", client_fd);
        
        /**
         * HERE IS THE CALLBACK TO THE HTTP_LAYER!
         * SEND THE NEWLY ACCEPTED CLIENT UPWARDS!
         **/
        if (self->upper_http_layer && self->cb_to_http_layer.tcp_on_newly_accepted_client)
        {
			printf("[TCP] >> Calling HTTP callback...\n"); // ADD THIS		   
            self->cb_to_http_layer.tcp_on_newly_accepted_client(self->upper_http_layer, client_fd);
			printf("[TCP] >> HTTP callback returned\n");
        }
		else
		{
			printf("[TCP] >> ERROR: No callback configured!\n");
			close(client_fd);
		}
    }

    return 0;
}

void tcp_server_close(tcp_server_t *self)
{
    if (!self) return;
    if (self->listen_fd >= 0) close(self->listen_fd);
    self->listen_fd = -1;
    self->state = TCP_SERVER_ERROR;
}
/**
 * Implementation-file: weather_server.c
 **/

#include "../../include/weather/weather_server.h"
#include "../../include/task_scheduler/task_scheduler.h"
#include <string.h>
#include <stdio.h>

int8_t weather_server_init(weather_server_t *self)
{
    if (!self) return -1;
    memset(self, 0, sizeof(*self));
    
    self->pool_size = WEATHER_POOL_SIZE;
    self->active_count = 0;
    
    // Initialize connection pool
    for (int i = 0; i < WEATHER_POOL_SIZE; i++)
    {
        self->child_weather_connection[i].state = WEATHER_CONNECTION_IDLE;
        self->child_weather_connection[i].parent = self;
        self->child_weather_connection[i].node.work = weather_connection_work;
        self->child_weather_connection[i].node.active = 0;
        
        // Set up callback - weather child knows how to handle requests
        self->child_weather_connection[i].cb_from_http_layer.http_on_request = 
            weather_connection_on_request_cb;
    }
    
    printf("[WEATHER SERVER] >> Initialized with pool size %d\n", WEATHER_POOL_SIZE);
    return 0;
}

weather_connection_t *weather_server_allocate_pool_slot(weather_server_t *self)
{
    if (!self) return NULL;
    
    for (int i = 0; i < WEATHER_POOL_SIZE; i++)
    {
        if (self->child_weather_connection[i].state == WEATHER_CONNECTION_IDLE)
        {
            printf("[WEATHER SERVER] >> Allocated pool slot [%d]\n", i);
            return &self->child_weather_connection[i];
        }
    }
    
    printf("[WEATHER SERVER] >> Pool full!\n");
    return NULL;
}
/**
 * Implementation-file: weather_connection.c
 **/

#include "../../include/weather/weather_connection.h"
#include "../../include/http/http_connection.h"
#include "../../include/task_scheduler/task_scheduler.h"
#include <stdio.h>
#include <string.h>

/**
 * THIS IS THE CALLBACK FUNCTION - HTTP CHILD HANDS PARSED REQUEST TO WEATHER CHILD
 **/
void weather_connection_on_request_cb(struct weather_connection *self, const struct http_request *request)
{
    if (!self || !request) return;
    
    printf("[WEATHER_CONN_CB] >> Received request from HTTP child\n");
    printf("[WEATHER_CONN_CB] >> Method: %s, Path: %s, Query: %s\n", 
           request->method, request->path, request->query);
    
    self->state = WEATHER_CONNECTION_PROCESSING;
    
    // Route based on path using strcmp
    if (strcmp(request->path, "/weather") == 0)
    {
        strncpy(self->request_type, "current", sizeof(self->request_type) - 1);
        printf("[WEATHER_CONN_CB] >> Request type: current weather\n");
    }
    else if (strcmp(request->path, "/forecast") == 0)
    {
        strncpy(self->request_type, "forecast", sizeof(self->request_type) - 1);
        printf("[WEATHER_CONN_CB] >> Request type: forecast\n");
    }
    else if (strcmp(request->path, "/") == 0)
    {
        strncpy(self->request_type, "default", sizeof(self->request_type) - 1);
        printf("[WEATHER_CONN_CB] >> Request type: default\n");
    }
    else
    {
        strncpy(self->request_type, "unknown", sizeof(self->request_type) - 1);
        printf("[WEATHER_CONN_CB] >> Request type: unknown\n");
    }
    
    // Parse city from query (simple parsing: city=Stockholm)
    const char *city_param = strstr(request->query, "city=");
    if (city_param)
    {
        strncpy(self->city, city_param + 5, sizeof(self->city) - 1);
        self->city[sizeof(self->city) - 1] = '\0';
        
        // Remove any trailing & or other params
        char *end = strchr(self->city, '&');
        if (end) *end = '\0';
    }
    else
    {
        strncpy(self->city, "Stockholm", sizeof(self->city) - 1); // Default
    }
    
    // Register with scheduler to do async work
    self->node.active = 0;
    task_scheduler_add(&self->node);
    self->parent->active_count++;
    
    printf("[WEATHER_CONN_CB] >> Weather child processing for city: %s\n", self->city);
}

int8_t weather_connection_work(task_node_t *node)
{
    weather_connection_t *self = container_of(node, weather_connection_t, node);
    
    printf("[WEATHER_CONN_WORK] >> Called, state=%d\n", self->state);
    
    if (!self) return -1;
    
    switch (self->state)
    {
        case WEATHER_CONNECTION_PROCESSING:
        {
            printf("[WEATHER_CONN] >> Processing weather request\n");
            
            // Route to backend state machines based on request type
            // TODO: This is where you'd call actual backend APIs
            if (strcmp(self->request_type, "current") == 0)
            {
                // TODO: Spawn backend API client child for current weather
                snprintf(self->response, sizeof(self->response),
                    "Current weather in %s: Sunny, 20°C\n", self->city);
            }
            else if (strcmp(self->request_type, "forecast") == 0)
            {
                // TODO: Spawn backend API client child for forecast
                snprintf(self->response, sizeof(self->response),
                    "5-day forecast for %s: Mostly sunny, 18-22°C\n", self->city);
            }
            else if (strcmp(self->request_type, "default") == 0)
            {
                snprintf(self->response, sizeof(self->response),
                    "Weather API\n\nAvailable endpoints:\n"
                    "  /weather?city=NAME - Current weather\n"
                    "  /forecast?city=NAME - 5-day forecast\n");
            }
            else
            {
                snprintf(self->response, sizeof(self->response),
                    "404 Not Found\n\nUnknown endpoint: %s\n", self->request_type);
            }
            
            printf("[WEATHER_CONN] >> Generated response: %s", self->response);
            
            // Call back to HTTP child with response
            if (self->lower_http_connection && 
                self->lower_http_connection->cb_from_weather_layer.weather_on_response)
            {
                printf("[WEATHER_CONN] >> Calling HTTP child response callback\n");
                self->lower_http_connection->cb_from_weather_layer.weather_on_response(
                    self->lower_http_connection,
                    self->response
                );
            }
            
            self->state = WEATHER_CONNECTION_DONE;
            return 0;
        }
        
        case WEATHER_CONNECTION_DONE:
        {
            printf("[WEATHER_CONN] >> Processing done, returning to pool\n");
            
            // Clean up and return to pool
            self->state = WEATHER_CONNECTION_IDLE;
            self->lower_http_connection = NULL;
            memset(self->request_type, 0, sizeof(self->request_type));
            memset(self->city, 0, sizeof(self->city));
            memset(self->response, 0, sizeof(self->response));
            
            task_scheduler_remove(&self->node);
            self->parent->active_count--;
            
            return 0;
        }
        
        default:
            return 0;
    }
    
    return 0;
}
